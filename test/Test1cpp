// vim: set ft=cpp;

#ifndef SP_TESSSST
#define SP_TESSSST
#endif

#include <iostream>

#define ASD class

#define SP_DDD_CLASS                                                           \
  ddd {                                                                        \
  }

#define NOTHING

namespace ns {
namespace ns1 { //
}
namespace ns11 { //
}
namespace {
//
}
}

namespace dd { /**/
namespace xx {
class TestBase { //
};
}
}
using namespace dd::xx;
using dd::xx::TestBase;

class /**/ TestBase2 /*:*/ /**/ /*TestBase*/ /**/ { //
                                                    //}
/**/}/**/;

class TestSub : public virtual TestBase {
  //};
};

class TestSub1 : virtual private TestBase {};

class TestSub2 : virtual private TestBase {
  /*};*/
};

class TestSub3 : private TestBase {
  //
};

class TestSub4 : virtual TestBase {
  //
};

class TestSub5 : TestBase {};

class TestSub6 : public virtual TestBase, virtual public TestBase2 {
  //};
};

class TestSub7 : virtual private TestBase, TestBase2 {};

class TestSub8 : virtual private TestBase, protected TestBase2 {
  /*};*/
};

class TestSub9 : private TestBase, TestBase2 {
  //
};

class TestSub10 : virtual TestBase, TestBase2 {
  //
};

class TestSub11 : TestBase, TestBase2 {};

class TestSub12 /*:*/ /*TestBase,*/ // TestBase2
{};

template <typename T>
class TestSub13 {};

template <typename = int>
class TestSub14 {};

template <typename T, typename B>
class TestSub15 {};

template <typename T = int>
class TestSub16 {};

template <typename T, typename B = int>
class TestSub17 {};

namespace asd {
template <int s = 1>
class TestSub18 {};

namespace ns1 {

ASD TestDefine{};
}

namespace ns2 {
class SP_DDD_CLASS;
}
}

NOTHING class NOTHING nothing {
  NOTHING
  //   NOTHING NOTHING
} NOTHING;
NOTHING

namespace sd {
template <typename T = int>
class TemplatedClass {};
}

template <sd::TemplatedClass<int> &asd>
class TemplatedClassRef {};

template <int asd = 3>
class templatedclassint {};

template <int *asd>
class templatedclassPtr {
  // int (&pa)[5];
  // void (*pf)(int, int *, int a, sd::TemplatedClass<int>);
};

// template <int **asd>
// class templatedclassPtrPtr {};

enum class EnumType1 : int {
  ONE,
  TWO, //
  THREE = 3,
  FOUR
};

// template <EnumType1 e = EnumType1::ONE>
// class templatedclassEnum {};

// template <int (&pa)[5]>
// struct TemplateClassArrayTypeParam {};
//
// template <void (*pf)(int, int *, int a, sd::TemplatedClass<int>)>
// struct TemplateClassFunctionPointerTypeParam {};

namespace test {
int function0();
void function1();

void function2(int);
void function3(int f);

void function4(int f, int);
void function5(int, int f);

void function6(int *f, int *);
void function7(int &, int *f);

extern void extFunc0(int **f);
extern void extFunc1(int **f, int &&);

// static void staticFunc0(int **f);
// static void staticFunc1(int **f, int &&);
}
